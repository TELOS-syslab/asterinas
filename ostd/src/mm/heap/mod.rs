// SPDX-License-Identifier: MPL-2.0

//! Managing the kernel heap with the slab allocator or the buddy allocator.

use core::{
    alloc::{AllocError, GlobalAlloc, Layout},
    ptr::NonNull,
};

use slot::HeapSlot;

use crate::panic::abort;

pub mod slab;
pub mod slot;
pub mod slot_list;

/// The trait for the global heap allocator.
///
/// By providing the slab and heap slot mechanism, OSTD allows users to
/// implement their own kernel heap in a safe way, instead of the unsafe
/// counterpart [`core::alloc::GlobalAlloc`].
///
/// To provide the global heap allocator, use [`crate::global_heap_allocator`]
/// to mark a static variable that implements this trait.
pub trait GlobalHeapAllocator: Sync {
    /// Allocates a heap slot according to the layout.
    fn alloc(&self, layout: Layout) -> Result<HeapSlot, AllocError>;

    /// Deallocates a contiguous range of frames.
    fn dealloc(&self, slot: HeapSlot) -> Result<(), AllocError>;
}

extern "Rust" {
    /// The reference to the global heap allocator generated by the
    /// [`crate::global_heap_allocator`] attribute.
    static __GLOBAL_HEAP_ALLOCATOR_REF: &'static dyn GlobalHeapAllocator;
}

#[alloc_error_handler]
fn handle_alloc_error(layout: core::alloc::Layout) -> ! {
    log::error!("Heap allocation error, layout = {:?}", layout);
    abort();
}

#[global_allocator]
static HEAP_ALLOCATOR: AllocDispatch = AllocDispatch;

struct AllocDispatch;

unsafe impl GlobalAlloc for AllocDispatch {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let res = unsafe { __GLOBAL_HEAP_ALLOCATOR_REF.alloc(layout) };

        res.map_or(core::ptr::null_mut(), |slot| slot.as_ptr())
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        let slot = unsafe { HeapSlot::new(NonNull::new_unchecked(ptr), layout.size()) };
        let res = unsafe { __GLOBAL_HEAP_ALLOCATOR_REF.dealloc(slot) };

        if res.is_err() {
            log::error!(
                "Heap deallocation error, ptr = {:p}, layout = {:?}",
                ptr,
                layout,
            );
            abort();
        }
    }
}
